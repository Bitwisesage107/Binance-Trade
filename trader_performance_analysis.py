# -*- coding: utf-8 -*-
"""Prime_Rashid.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G1zn1IIPYbQgmNnIPJP9EjvXTSeFDlaG
"""

import pandas as pd
import numpy as np
import os
import logging
from scipy.stats import norm

trades_df = pd.read_csv("/content/sample_data/TRADES_CopyTr_90D_ROI.csv")
print(trades_df.head())
print(trades_df.info())

print(type(trades_df['Trade_History'].loc[0]))

import ast  # Importing ast for safe evaluation of strings

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Data Loading and Exploration

def clean_trade_data(trade_data):
    cleaned_trades = []

    if isinstance(trade_data, str):  # Parse the string using ast.literal_eval
        try:
            trade_list = ast.literal_eval(trade_data) # Safely evaluate the string
            if isinstance(trade_list, list): # Check if the evaluated object is a list
                for i, trade in enumerate(trade_list):
                    try:
                        original_time = trade.get('time')
                        new_trade = trade.copy()

                        try:  # Time conversion
                            new_trade['time'] = pd.to_datetime(trade['time'], unit='ms')
                            if pd.isna(new_trade['time']):
                                raise ValueError("Invalid or out-of-range timestamp")
                        except (ValueError, pd.errors.OutOfBoundsDatetime) as e:
                            logging.error(f"Trade {i} (original time: {original_time}): Time conversion error: {e}. Skipping.")
                            continue

                        try:  # realizedProfit conversion
                            new_trade['realizedProfit'] = float(trade['realizedProfit'])
                        except (ValueError, TypeError) as e:
                            logging.error(f"Trade {i} (original time: {original_time}): realizedProfit conversion error: {e}. Skipping.")
                            continue

                        cleaned_trades.append(new_trade)

                    except Exception as e:
                        logging.error(f"Unexpected error processing trade {i}: {e}. Skipping trade.")
                        continue
            elif isinstance(trade_list, dict): # Check if the evaluated object is a dictionary
                try:
                    original_time = trade_list.get('time')
                    new_trade = trade_list.copy()

                    try:  # Time conversion
                        new_trade['time'] = pd.to_datetime(trade_list['time'], unit='ms')
                        if pd.isna(new_trade['time']):
                            raise ValueError("Invalid or out-of-range timestamp")
                    except (ValueError, pd.errors.OutOfBoundsDatetime) as e:
                        logging.error(f"Single trade (original time: {original_time}): Time conversion error: {e}. Skipping.")
                        return []

                    try:  # realizedProfit conversion
                        new_trade['realizedProfit'] = float(trade_list['realizedProfit'])
                    except (ValueError, TypeError) as e:
                        logging.error(f"Single trade (original time: {original_time}): realizedProfit conversion error: {e}. Skipping.")
                        return []

                    cleaned_trades.append(new_trade)

                except Exception as e:
                    logging.error(f"Unexpected error processing single trade: {e}. Skipping trade.")
                    return []
            else:
                logging.warning(f"Unexpected evaluated structure: {type(trade_list)}. Skipping.")
                pass
        except (SyntaxError, ValueError) as e:  # Catch evaluation errors
            logging.error(f"Error evaluating string: {e}. Skipping.")
            return [] # Return empty if can't evaluate

    elif isinstance(trade_data, list): # Check if it's already a list (no evaluation needed)
        for i, trade in enumerate(trade_data):
            try:
                original_time = trade.get('time')
                new_trade = trade.copy()

                try:  # Time conversion
                    new_trade['time'] = pd.to_datetime(trade['time'], unit='ms')
                    if pd.isna(new_trade['time']):
                        raise ValueError("Invalid or out-of-range timestamp")
                except (ValueError, pd.errors.OutOfBoundsDatetime) as e:
                    logging.error(f"Trade {i} (original time: {original_time}): Time conversion error: {e}. Skipping.")
                    continue

                try:  # realizedProfit conversion
                    new_trade['realizedProfit'] = float(trade['realizedProfit'])
                except (ValueError, TypeError) as e:
                    logging.error(f"Trade {i} (original time: {original_time}): realizedProfit conversion error: {e}. Skipping.")
                    continue

                cleaned_trades.append(new_trade)

            except Exception as e:
                logging.error(f"Unexpected error processing trade {i}: {e}. Skipping trade.")
                continue

    elif isinstance(trade_data, dict):
        try:
            original_time = trade_data.get('time')
            new_trade = trade_data.copy()

            try:  # Time conversion
                new_trade['time'] = pd.to_datetime(trade_data['time'], unit='ms')
                if pd.isna(new_trade['time']):
                    raise ValueError("Invalid or out-of-range timestamp")
            except (ValueError, pd.errors.OutOfBoundsDatetime) as e:
                logging.error(f"Single trade (original time: {original_time}): Time conversion error: {e}. Skipping.")
                return []

            try:  # realizedProfit conversion
                new_trade['realizedProfit'] = float(trade_data['realizedProfit'])
            except (ValueError, TypeError) as e:
                logging.error(f"Single trade (original time: {original_time}): realizedProfit conversion error: {e}. Skipping.")
                return []

            cleaned_trades.append(new_trade)

        except Exception as e:
            logging.error(f"Unexpected error processing single trade: {e}. Skipping trade.")
            return []

    elif isinstance(trade_data, (int, float, np.number)):
        logging.warning(f"Trade_History entry is a number: {trade_data}. Skipping.")
        pass
    else:
        logging.warning(f"Unexpected data type in Trade_History: {type(trade_data)}. Skipping.")
        pass

    return cleaned_trades


trades_df['Trade_History'] = trades_df['Trade_History'].apply(clean_trade_data)

# ... (Rest of the code - same as before) ...

# 3. Feature Engineering and Metric Calculation
def calculate_metrics(group):
    all_trades = []
    for trade_list in group['Trade_History']:
        all_trades.extend(trade_list) # flatten the list of lists
    group_metrics = pd.Series(index=['ROI','PnL','Sharpe Ratio','MDD','Win Rate','Win Positions','Total Positions'])
    if not all_trades: # if list is empty, default to 0
        group_metrics[:] = 0
        return group_metrics
    trades_df_temp = pd.DataFrame(all_trades) # Create a temp dataframe
    total_positions = len(trades_df_temp)
    win_positions = len(trades_df_temp[trades_df_temp['realizedProfit'] > 0])
    win_rate = (win_positions / total_positions) if total_positions > 0 else 0

    # Calculate ROI (Return on Investment)
    initial_balance = 1  # Assuming a starting balance of 1 for simplicity (you may use a different value if you have it)
    final_balance = initial_balance + trades_df_temp['realizedProfit'].sum()
    roi = ((final_balance - initial_balance) / initial_balance) * 100

    # Calculate PnL (Profit and Loss)
    pnl = trades_df_temp['realizedProfit'].sum()

    # Calculate Sharpe Ratio (assuming daily returns)
    daily_returns = trades_df_temp.set_index('time')['realizedProfit'].resample('D').sum() # Resample to daily
    average_daily_return = daily_returns.mean()
    std_dev_daily_return = daily_returns.std()
    sharpe_ratio = np.sqrt(252) * average_daily_return / std_dev_daily_return if std_dev_daily_return > 0 else 0 # Assuming 252 trading days in a year

    # Calculate MDD (Maximum Drawdown)
    cumulative_returns = (1 + daily_returns.fillna(0)).cumprod() # Fillna to handle potential NaNs from resampling
    peak = cumulative_returns.max()
    drawdown = (cumulative_returns - peak) / peak
    mdd = drawdown.min()

    return pd.Series({
        'ROI': roi,
        'PnL': pnl,
        'Sharpe Ratio': sharpe_ratio,
        'MDD': mdd,
        'Win Rate': win_rate,
        'Win Positions': win_positions,
        'Total Positions': total_positions
    })

metrics_df = trades_df.groupby('Port_IDs').apply(calculate_metrics).reset_index()

# 4. Ranking and Top 20 List (same as before)
weights = {
    'ROI': 0.3,
    'PnL': 0.25,
    'Sharpe Ratio': 0.2,
    'MDD': 0.15,  # We want to minimize MDD
    'Win Rate': 0.1
}

for metric in weights:
    if metric != 'MDD':
        metrics_df[metric] = (metrics_df[metric] - metrics_df[metric].min()) / (metrics_df[metric].max() - metrics_df[metric].min())
    else:
        metrics_df[metric] = (metrics_df[metric].max() - metrics_df[metric]) / (metrics_df[metric].max() - metrics_df[metric].min())

metrics_df['score'] = sum(metrics_df[metric] * weights[metric] for metric in weights)
metrics_df['rank'] = metrics_df['score'].rank(ascending=False)
top_20 = metrics_df.sort_values('score', ascending=False).head(20)

print(top_20)

# 5. Deliverable
metrics_df.to_csv("account_metrics.csv", index=False)
top_20.to_csv("top_20_accounts.csv", index=False)